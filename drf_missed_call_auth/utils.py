import hashlib
import logging
from typing import Type
from django.utils.crypto import constant_time_compare
from django.utils.translation import gettext as _
from .settings import api_settings

logger = logging.getLogger(__name__)

def validate_app_signature(provided_signature: str) -> bool:
    """
    Validates that the request is coming from an authorized mobile binary.
    
    In a high-level flash-call flow, the 'signature' is typically a hash 
    generated by the mobile OS (like the Android App Hash).
    """
    if not api_settings.REQUIRE_SIGNATURE:
        return True

    if not provided_signature:
        return False

    # Retrieve the allowed signatures from settings (can be a list for dev/prod builds)
    allowed_signatures = getattr(api_settings, 'ALLOWED_APP_SIGNATURES', [])
    
    # If it's a single string, wrap it in a list
    if isinstance(allowed_signatures, str):
        allowed_signatures = [allowed_signatures]

    # Use constant_time_compare to prevent side-channel timing attacks
    return any(
        constant_time_compare(provided_signature, sig) 
        for sig in allowed_signatures
    )

def get_gateway():
    """
    Factory function that dynamically loads the Gateway class 
    specified in the settings. This follows the DRF 'pluggable' pattern.
    """
    gateway_instance = api_settings.GATEWAY_CLASS
    
    # If the setting is a string (lazy import), DRF's APISettings 
    # already handled the import during access if configured in IMPORT_STRINGS.
    if isinstance(gateway_instance, type):
        return gateway_instance()
    
    return gateway_instance

def normalize_phone_number(phone: str) -> str:
    """
    Standardizes phone numbers to strict E.164 format.
    Example: ' (555) 123-4567' -> '+5551234567'
    """
    if not phone:
        return ""
    
    # Strip everything except digits
    digits = "".join(filter(str.isdigit, phone))
    
    # Ensure it starts with exactly one '+'
    return f"+{digits}"